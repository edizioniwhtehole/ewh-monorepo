<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BoxCAD Pro - Web CAD System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #1e1e1e;
      color: #fff;
      overflow: hidden;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .header {
      background: #2d2d30;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #3e3e42;
    }

    .header h1 {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
    }

    .header-actions {
      display: flex;
      gap: 10px;
    }

    .btn {
      padding: 6px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #0e639c;
      color: #fff;
    }

    .btn-primary:hover {
      background: #1177bb;
    }

    .btn-secondary {
      background: #3e3e42;
      color: #fff;
    }

    .btn-secondary:hover {
      background: #4e4e52;
    }

    /* Main Content */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Left Sidebar - Tools */
    .left-sidebar {
      width: 60px;
      background: #252526;
      border-right: 1px solid #3e3e42;
      display: flex;
      flex-direction: column;
      padding: 10px 0;
      gap: 5px;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      margin: 0 auto;
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tool-btn:hover {
      background: #3e3e42;
      color: #fff;
    }

    .tool-btn.active {
      background: #0e639c;
      color: #fff;
    }

    .tool-separator {
      height: 1px;
      background: #3e3e42;
      margin: 5px 10px;
    }

    /* Canvas Area */
    .canvas-container {
      flex: 1;
      position: relative;
      background: #1e1e1e;
    }

    #canvas {
      display: block;
      cursor: crosshair;
    }

    /* Right Sidebar - Properties */
    .right-sidebar {
      width: 280px;
      background: #252526;
      border-left: 1px solid #3e3e42;
      padding: 20px;
      overflow-y: auto;
    }

    .property-section {
      margin-bottom: 20px;
    }

    .property-section h3 {
      font-size: 13px;
      font-weight: 600;
      color: #ccc;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .property-input {
      margin-bottom: 12px;
    }

    .property-input label {
      display: block;
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }

    .property-input input,
    .property-input select {
      width: 100%;
      padding: 6px 8px;
      background: #3c3c3c;
      border: 1px solid #3e3e42;
      border-radius: 3px;
      color: #fff;
      font-size: 13px;
    }

    .property-input input:focus,
    .property-input select:focus {
      outline: none;
      border-color: #0e639c;
    }

    /* Status Bar */
    .status-bar {
      background: #007acc;
      padding: 4px 20px;
      font-size: 12px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      border-top: 1px solid #3e3e42;
    }

    .coordinates {
      font-family: 'Courier New', monospace;
    }

    /* Context Menu */
    .context-menu {
      position: absolute;
      background: #2d2d30;
      border: 1px solid #3e3e42;
      border-radius: 4px;
      padding: 4px 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      display: none;
      z-index: 1000;
    }

    .context-menu-item {
      padding: 6px 20px;
      font-size: 13px;
      cursor: pointer;
      color: #ccc;
    }

    .context-menu-item:hover {
      background: #3e3e42;
      color: #fff;
    }

    .context-menu-separator {
      height: 1px;
      background: #3e3e42;
      margin: 4px 0;
    }

    /* Object List */
    .object-list {
      list-style: none;
      margin-top: 10px;
    }

    .object-item {
      padding: 6px 10px;
      background: #3c3c3c;
      border: 1px solid #3e3e42;
      border-radius: 3px;
      margin-bottom: 4px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .object-item:hover {
      background: #4e4e52;
    }

    .object-item.selected {
      background: #0e639c;
      border-color: #1177bb;
    }

    .object-delete {
      color: #f48771;
      cursor: pointer;
      font-size: 16px;
    }

    .object-delete:hover {
      color: #ff5555;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <div class="header">
      <h1>üìê BoxCAD Pro - Web-Based CAD System</h1>
      <div class="header-actions">
        <button class="btn btn-secondary" onclick="app.undo()">‚Ü∂ Undo</button>
        <button class="btn btn-secondary" onclick="app.redo()">‚Ü∑ Redo</button>
        <button class="btn btn-primary" onclick="app.exportSVG()">üì• Export SVG</button>
        <button class="btn btn-primary" onclick="app.exportDXF()">üì• Export DXF</button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Left Sidebar - Tools -->
      <div class="left-sidebar">
        <button class="tool-btn active" data-tool="select" title="Select (V)">‚óâ</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" data-tool="line" title="Line (L)">‚ï±</button>
        <button class="tool-btn" data-tool="rectangle" title="Rectangle (R)">‚ñ≠</button>
        <button class="tool-btn" data-tool="circle" title="Circle (C)">‚óã</button>
        <button class="tool-btn" data-tool="arc" title="Arc (A)">‚åí</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" data-tool="trim" title="Trim (T)">‚úÇ</button>
        <button class="tool-btn" data-tool="offset" title="Offset (O)">‚Üî</button>
        <button class="tool-btn" data-tool="fillet" title="Fillet (F)">‚åí</button>
        <button class="tool-btn" data-tool="mirror" title="Mirror (M)">‚áÑ</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" data-tool="dimension" title="Dimension (D)">üìè</button>
      </div>

      <!-- Canvas Area -->
      <div class="canvas-container">
        <canvas id="canvas" width="1200" height="800"></canvas>
      </div>

      <!-- Right Sidebar - Properties -->
      <div class="right-sidebar">
        <div class="property-section">
          <h3>Current Tool</h3>
          <div id="currentToolName" style="font-size: 14px; color: #fff;">Select</div>
        </div>

        <div class="property-section">
          <h3>Drawing Settings</h3>

          <div class="property-input">
            <label>Line Type:</label>
            <select id="lineType" onchange="app.setLineType(this.value)">
              <option value="cut">Cut (Red)</option>
              <option value="crease">Crease (Blue)</option>
              <option value="perforation">Perforation (Magenta)</option>
              <option value="construction">Construction (Gray)</option>
            </select>
          </div>

          <div class="property-input">
            <label>
              <input type="checkbox" id="snapToGrid" checked onchange="app.setSnapToGrid(this.checked)">
              Snap to Grid (10mm)
            </label>
          </div>

          <div class="property-input">
            <label>
              <input type="checkbox" id="showGrid" checked onchange="app.setShowGrid(this.checked)">
              Show Grid
            </label>
          </div>
        </div>

        <div class="property-section">
          <h3>Tool Parameters</h3>
          <div id="toolParams"></div>
        </div>

        <div class="property-section">
          <h3>Objects (<span id="objectCount">0</span>)</h3>
          <ul class="object-list" id="objectList"></ul>
        </div>

        <div class="property-section">
          <h3>Statistics</h3>
          <div style="font-size: 12px; color: #aaa; line-height: 1.6;">
            <div>Zoom: <span id="zoomLevel">100%</span></div>
            <div>Cursor: <span id="cursorPos">0, 0</span></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div id="statusMessage">Ready</div>
      <div class="coordinates">
        <span id="coordinates">X: 0.0mm, Y: 0.0mm</span>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="app.deleteSelected()">Delete</div>
    <div class="context-menu-item" onclick="app.copySelected()">Copy</div>
    <div class="context-menu-item" onclick="app.pasteSelected()">Paste</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="app.bringToFront()">Bring to Front</div>
    <div class="context-menu-item" onclick="app.sendToBack()">Send to Back</div>
  </div>

  <script>
    // CAD Application
    class CADApp {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');

        // State
        this.objects = [];
        this.selectedObjects = [];
        this.history = [];
        this.historyIndex = -1;
        this.currentTool = 'select';
        this.currentLineType = 'cut';

        // Drawing state
        this.isDrawing = false;
        this.startPoint = null;
        this.currentPoint = null;
        this.tempObject = null;

        // View state
        this.zoom = 1;
        this.panX = 50;
        this.panY = 50;
        this.showGrid = true;
        this.snapToGrid = true;
        this.gridSize = 10; // mm

        // Tool parameters
        this.offsetDistance = 10;
        this.filletRadius = 5;

        this.init();
      }

      init() {
        // Resize canvas to fill container
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => this.onContextMenu(e));

        // Keyboard events
        window.addEventListener('keydown', (e) => this.onKeyDown(e));

        // Tool buttons
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            this.setTool(btn.dataset.tool);
          });
        });

        // Initial render
        this.render();
        this.updateUI();
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.render();
      }

      // Coordinate conversion
      screenToWorld(screenX, screenY) {
        const rect = this.canvas.getBoundingClientRect();
        let x = (screenX - rect.left - this.panX) / this.zoom;
        let y = (screenY - rect.top - this.panY) / this.zoom;

        if (this.snapToGrid) {
          x = Math.round(x / this.gridSize) * this.gridSize;
          y = Math.round(y / this.gridSize) * this.gridSize;
        }

        return { x, y };
      }

      worldToScreen(worldX, worldY) {
        return {
          x: worldX * this.zoom + this.panX,
          y: worldY * this.zoom + this.panY
        };
      }

      // Mouse handlers
      onMouseDown(e) {
        if (e.button !== 0) return; // Only left click

        const point = this.screenToWorld(e.clientX, e.clientY);
        this.startPoint = point;
        this.isDrawing = true;

        if (this.currentTool === 'select') {
          const hitObject = this.getObjectAt(point);
          if (hitObject) {
            if (!e.shiftKey) {
              this.selectedObjects = [hitObject];
            } else {
              const index = this.selectedObjects.indexOf(hitObject);
              if (index === -1) {
                this.selectedObjects.push(hitObject);
              } else {
                this.selectedObjects.splice(index, 1);
              }
            }
          } else {
            this.selectedObjects = [];
          }
          this.updateUI();
        }
      }

      onMouseMove(e) {
        const point = this.screenToWorld(e.clientX, e.clientY);
        this.currentPoint = point;

        // Update cursor position display
        document.getElementById('coordinates').textContent =
          `X: ${point.x.toFixed(1)}mm, Y: ${point.y.toFixed(1)}mm`;
        document.getElementById('cursorPos').textContent =
          `${point.x.toFixed(1)}, ${point.y.toFixed(1)}`;

        if (this.isDrawing && this.startPoint) {
          // Preview current drawing
          this.render();
          this.drawPreview();
        } else {
          this.render();
        }
      }

      onMouseUp(e) {
        if (!this.isDrawing) return;

        const point = this.screenToWorld(e.clientX, e.clientY);
        this.isDrawing = false;

        // Create object based on tool
        let newObject = null;

        switch (this.currentTool) {
          case 'line':
            newObject = {
              type: 'line',
              lineType: this.currentLineType,
              p1: this.startPoint,
              p2: point
            };
            break;

          case 'rectangle':
            newObject = {
              type: 'rectangle',
              lineType: this.currentLineType,
              x: Math.min(this.startPoint.x, point.x),
              y: Math.min(this.startPoint.y, point.y),
              width: Math.abs(point.x - this.startPoint.x),
              height: Math.abs(point.y - this.startPoint.y)
            };
            break;

          case 'circle':
            const radius = Math.hypot(point.x - this.startPoint.x, point.y - this.startPoint.y);
            newObject = {
              type: 'circle',
              lineType: this.currentLineType,
              cx: this.startPoint.x,
              cy: this.startPoint.y,
              radius: radius
            };
            break;

          case 'arc':
            const arcRadius = Math.hypot(point.x - this.startPoint.x, point.y - this.startPoint.y);
            newObject = {
              type: 'arc',
              lineType: this.currentLineType,
              cx: this.startPoint.x,
              cy: this.startPoint.y,
              radius: arcRadius,
              startAngle: 0,
              endAngle: Math.PI
            };
            break;
        }

        if (newObject) {
          this.addObject(newObject);
        }

        this.startPoint = null;
        this.render();
      }

      onWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.zoom *= delta;
        this.zoom = Math.max(0.1, Math.min(10, this.zoom));

        document.getElementById('zoomLevel').textContent = `${Math.round(this.zoom * 100)}%`;
        this.render();
      }

      onContextMenu(e) {
        e.preventDefault();
        const menu = document.getElementById('contextMenu');
        menu.style.display = 'block';
        menu.style.left = e.clientX + 'px';
        menu.style.top = e.clientY + 'px';

        // Close menu on click outside
        setTimeout(() => {
          document.addEventListener('click', () => {
            menu.style.display = 'none';
          }, { once: true });
        }, 0);
      }

      onKeyDown(e) {
        // Tool shortcuts
        const shortcuts = {
          'v': 'select',
          'l': 'line',
          'r': 'rectangle',
          'c': 'circle',
          'a': 'arc',
          't': 'trim',
          'o': 'offset',
          'f': 'fillet',
          'm': 'mirror',
          'd': 'dimension'
        };

        if (shortcuts[e.key.toLowerCase()]) {
          this.setTool(shortcuts[e.key.toLowerCase()]);
        }

        // Undo/Redo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          this.undo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          this.redo();
        }

        // Delete
        if (e.key === 'Delete' || e.key === 'Backspace') {
          this.deleteSelected();
        }

        // Escape
        if (e.key === 'Escape') {
          this.selectedObjects = [];
          this.isDrawing = false;
          this.startPoint = null;
          this.render();
          this.updateUI();
        }
      }

      // Tool management
      setTool(tool) {
        this.currentTool = tool;

        // Update UI
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tool === tool);
        });

        const toolNames = {
          'select': 'Select',
          'line': 'Line',
          'rectangle': 'Rectangle',
          'circle': 'Circle',
          'arc': 'Arc',
          'trim': 'Trim',
          'offset': 'Offset',
          'fillet': 'Fillet',
          'mirror': 'Mirror',
          'dimension': 'Dimension'
        };

        document.getElementById('currentToolName').textContent = toolNames[tool] || tool;
        document.getElementById('statusMessage').textContent = `Tool: ${toolNames[tool]}`;

        // Update tool parameters panel
        this.updateToolParams();
      }

      setLineType(type) {
        this.currentLineType = type;
      }

      setSnapToGrid(snap) {
        this.snapToGrid = snap;
      }

      setShowGrid(show) {
        this.showGrid = show;
        this.render();
      }

      updateToolParams() {
        const paramsDiv = document.getElementById('toolParams');
        paramsDiv.innerHTML = '';

        if (this.currentTool === 'offset') {
          paramsDiv.innerHTML = `
            <div class="property-input">
              <label>Distance (mm):</label>
              <input type="number" value="${this.offsetDistance}"
                onchange="app.offsetDistance = parseFloat(this.value)" step="1" min="0.1">
            </div>
          `;
        } else if (this.currentTool === 'fillet') {
          paramsDiv.innerHTML = `
            <div class="property-input">
              <label>Radius (mm):</label>
              <input type="number" value="${this.filletRadius}"
                onchange="app.filletRadius = parseFloat(this.value)" step="0.5" min="0.5">
            </div>
          `;
        }
      }

      // Object management
      addObject(obj) {
        this.objects.push(obj);
        this.saveHistory();
        this.updateUI();
        this.render();
      }

      deleteSelected() {
        if (this.selectedObjects.length === 0) return;

        this.selectedObjects.forEach(obj => {
          const index = this.objects.indexOf(obj);
          if (index > -1) {
            this.objects.splice(index, 1);
          }
        });

        this.selectedObjects = [];
        this.saveHistory();
        this.updateUI();
        this.render();
      }

      getObjectAt(point) {
        // Iterate in reverse (top objects first)
        for (let i = this.objects.length - 1; i >= 0; i--) {
          const obj = this.objects[i];
          if (this.isPointNearObject(point, obj, 5)) {
            return obj;
          }
        }
        return null;
      }

      isPointNearObject(point, obj, tolerance) {
        if (obj.type === 'line') {
          const dist = this.distancePointToLine(point, obj.p1, obj.p2);
          return dist < tolerance;
        }
        if (obj.type === 'circle') {
          const dist = Math.hypot(point.x - obj.cx, point.y - obj.cy);
          return Math.abs(dist - obj.radius) < tolerance;
        }
        if (obj.type === 'rectangle') {
          return point.x >= obj.x - tolerance && point.x <= obj.x + obj.width + tolerance &&
                 point.y >= obj.y - tolerance && point.y <= obj.y + obj.height + tolerance;
        }
        return false;
      }

      distancePointToLine(point, p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        if (len < 0.001) return Math.hypot(point.x - p1.x, point.y - p1.y);

        const t = Math.max(0, Math.min(1,
          ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (len * len)
        ));

        const projX = p1.x + t * dx;
        const projY = p1.y + t * dy;

        return Math.hypot(point.x - projX, point.y - projY);
      }

      // History
      saveHistory() {
        if (this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex + 1);
        }
        this.history.push(JSON.parse(JSON.stringify(this.objects)));
        this.historyIndex++;

        if (this.history.length > 50) {
          this.history.shift();
          this.historyIndex--;
        }
      }

      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.objects = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
          this.updateUI();
          this.render();
          document.getElementById('statusMessage').textContent = 'Undo';
        }
      }

      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.objects = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
          this.updateUI();
          this.render();
          document.getElementById('statusMessage').textContent = 'Redo';
        }
      }

      // Rendering
      render() {
        const ctx = this.ctx;

        // Clear
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.save();
        ctx.translate(this.panX, this.panY);
        ctx.scale(this.zoom, this.zoom);

        // Grid
        if (this.showGrid) {
          this.drawGrid();
        }

        // Objects
        this.objects.forEach(obj => {
          this.drawObject(obj, this.selectedObjects.includes(obj));
        });

        ctx.restore();
      }

      drawGrid() {
        const ctx = this.ctx;
        const gridExtent = 2000;

        // Light grid
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 0.5 / this.zoom;

        for (let x = 0; x <= gridExtent; x += this.gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, gridExtent);
          ctx.stroke();
        }

        for (let y = 0; y <= gridExtent; y += this.gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(gridExtent, y);
          ctx.stroke();
        }

        // Bold lines every 100mm
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 1 / this.zoom;

        for (let x = 0; x <= gridExtent; x += 100) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, gridExtent);
          ctx.stroke();
        }

        for (let y = 0; y <= gridExtent; y += 100) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(gridExtent, y);
          ctx.stroke();
        }

        // Origin
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2 / this.zoom;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(100, 0);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 100);
        ctx.stroke();
      }

      drawObject(obj, selected) {
        const ctx = this.ctx;

        // Line styles
        const styles = {
          'cut': { color: '#ff4444', width: 2, dash: [] },
          'crease': { color: '#4444ff', width: 1, dash: [5, 5] },
          'perforation': { color: '#ff44ff', width: 1, dash: [2, 3] },
          'construction': { color: '#888', width: 0.5, dash: [3, 3] }
        };

        const style = styles[obj.lineType] || styles['cut'];

        ctx.strokeStyle = selected ? '#00ff00' : style.color;
        ctx.lineWidth = (selected ? 3 : style.width) / this.zoom;
        ctx.setLineDash(style.dash.map(d => d / this.zoom));

        if (obj.type === 'line') {
          ctx.beginPath();
          ctx.moveTo(obj.p1.x, obj.p1.y);
          ctx.lineTo(obj.p2.x, obj.p2.y);
          ctx.stroke();
        } else if (obj.type === 'rectangle') {
          ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
        } else if (obj.type === 'circle') {
          ctx.beginPath();
          ctx.arc(obj.cx, obj.cy, obj.radius, 0, Math.PI * 2);
          ctx.stroke();
        } else if (obj.type === 'arc') {
          ctx.beginPath();
          ctx.arc(obj.cx, obj.cy, obj.radius, obj.startAngle, obj.endAngle);
          ctx.stroke();
        }

        ctx.setLineDash([]);
      }

      drawPreview() {
        if (!this.startPoint || !this.currentPoint) return;

        const ctx = this.ctx;
        ctx.save();
        ctx.translate(this.panX, this.panY);
        ctx.scale(this.zoom, this.zoom);

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 1 / this.zoom;
        ctx.setLineDash([5 / this.zoom, 5 / this.zoom]);
        ctx.globalAlpha = 0.5;

        if (this.currentTool === 'line') {
          ctx.beginPath();
          ctx.moveTo(this.startPoint.x, this.startPoint.y);
          ctx.lineTo(this.currentPoint.x, this.currentPoint.y);
          ctx.stroke();
        } else if (this.currentTool === 'rectangle') {
          const x = Math.min(this.startPoint.x, this.currentPoint.x);
          const y = Math.min(this.startPoint.y, this.currentPoint.y);
          const w = Math.abs(this.currentPoint.x - this.startPoint.x);
          const h = Math.abs(this.currentPoint.y - this.startPoint.y);
          ctx.strokeRect(x, y, w, h);
        } else if (this.currentTool === 'circle') {
          const r = Math.hypot(this.currentPoint.x - this.startPoint.x,
                               this.currentPoint.y - this.startPoint.y);
          ctx.beginPath();
          ctx.arc(this.startPoint.x, this.startPoint.y, r, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.restore();
      }

      // UI Updates
      updateUI() {
        document.getElementById('objectCount').textContent = this.objects.length;

        const listEl = document.getElementById('objectList');
        listEl.innerHTML = '';

        this.objects.forEach((obj, index) => {
          const item = document.createElement('li');
          item.className = 'object-item';
          if (this.selectedObjects.includes(obj)) {
            item.classList.add('selected');
          }

          const typeNames = {
            'line': 'Line',
            'rectangle': 'Rectangle',
            'circle': 'Circle',
            'arc': 'Arc'
          };

          item.innerHTML = `
            <span>${typeNames[obj.type] || obj.type} #${index + 1}</span>
            <span class="object-delete" onclick="app.deleteObject(${index})">√ó</span>
          `;

          item.addEventListener('click', (e) => {
            if (!e.target.classList.contains('object-delete')) {
              this.selectedObjects = [obj];
              this.updateUI();
              this.render();
            }
          });

          listEl.appendChild(item);
        });
      }

      deleteObject(index) {
        this.objects.splice(index, 1);
        this.selectedObjects = [];
        this.saveHistory();
        this.updateUI();
        this.render();
      }

      // Export
      exportSVG() {
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="1000" viewBox="0 0 1000 1000">\n`;

        this.objects.forEach(obj => {
          const styles = {
            'cut': 'stroke="red" stroke-width="2"',
            'crease': 'stroke="blue" stroke-width="1" stroke-dasharray="5,5"',
            'perforation': 'stroke="magenta" stroke-width="1" stroke-dasharray="2,3"',
            'construction': 'stroke="gray" stroke-width="0.5" stroke-dasharray="3,3"'
          };

          const style = styles[obj.lineType] || styles['cut'];

          if (obj.type === 'line') {
            svg += `  <line x1="${obj.p1.x}" y1="${obj.p1.y}" x2="${obj.p2.x}" y2="${obj.p2.y}" ${style} fill="none" />\n`;
          } else if (obj.type === 'rectangle') {
            svg += `  <rect x="${obj.x}" y="${obj.y}" width="${obj.width}" height="${obj.height}" ${style} fill="none" />\n`;
          } else if (obj.type === 'circle') {
            svg += `  <circle cx="${obj.cx}" cy="${obj.cy}" r="${obj.radius}" ${style} fill="none" />\n`;
          } else if (obj.type === 'arc') {
            const startX = obj.cx + obj.radius * Math.cos(obj.startAngle);
            const startY = obj.cy + obj.radius * Math.sin(obj.startAngle);
            const endX = obj.cx + obj.radius * Math.cos(obj.endAngle);
            const endY = obj.cy + obj.radius * Math.sin(obj.endAngle);
            const largeArc = (obj.endAngle - obj.startAngle) > Math.PI ? 1 : 0;
            svg += `  <path d="M ${startX} ${startY} A ${obj.radius} ${obj.radius} 0 ${largeArc} 1 ${endX} ${endY}" ${style} fill="none" />\n`;
          }
        });

        svg += `</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cad-drawing-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);

        document.getElementById('statusMessage').textContent = '‚úÖ SVG exported';
        setTimeout(() => {
          document.getElementById('statusMessage').textContent = 'Ready';
        }, 2000);
      }

      exportDXF() {
        alert('DXF export coming soon! Currently SVG export is available.');
      }

      // Placeholder methods for context menu
      copySelected() { alert('Copy feature coming soon'); }
      pasteSelected() { alert('Paste feature coming soon'); }
      bringToFront() { alert('Bring to front coming soon'); }
      sendToBack() { alert('Send to back coming soon'); }
    }

    // Initialize app
    const app = new CADApp();
  </script>
</body>
</html>
